# -*- coding: utf-8 -*-
"""Mortality_DW_Creation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WUOJsEFGvj7ItgxjJoKr41pezB4_dtMm
"""

# ‚úÖ Instalar dependencias
#!pip install pandas sqlalchemy openpyxl

import pandas as pd
from sqlalchemy import create_engine

# ‚úÖ Cargar archivos desde carpeta /content
file_mortalidad = "/content/NoFetal2019.xlsx"
file_codigos = "/content/CodigosDeMuerte.xlsx"
file_divipola = "/content/Divipola_CE_.xlsx"

df_mortalidad = pd.read_excel(file_mortalidad)
df_codigos_raw = pd.read_excel(file_codigos, skiprows=8)
df_divipola = pd.read_excel(file_divipola)

# ‚úÖ Transformar C√≥digos CIE-10 (dim_causa)
df_codigos = df_codigos_raw[[
    "C√≥digo de la CIE-10 cuatro caracteres",
    "C√≥digo de la CIE-10 tres caracteres",
    "Descripcion  de c√≥digos mortalidad a cuatro caracteres"
]].drop_duplicates()
df_codigos.columns = ["codigo", "codigo_cie10_tres_caracteres","descripcion"]

# No cambiar nombres, solo seleccionar lo necesario
df_divipola = df_divipola[["COD_DANE", "COD_DEPARTAMENTO","DEPARTAMENTO", "COD_MUNICIPIO","MUNICIPIO"]].drop_duplicates()

# ‚úÖ Transformar tiempo (dim_tiempo)
# Renombrar columnas A√ëO y MES a lo que espera pd.to_datetime
df_tiempo = df_mortalidad[["A√ëO", "MES", "HORA","MINUTOS"]].dropna().drop_duplicates()

# Calcular trimestre a partir del mes
df_tiempo["TRIMESTRE"] = ((df_tiempo["MES"] - 1) // 3 + 1).astype(int)

# Reorganizar columnas
df_tiempo = df_tiempo[["A√ëO", "MES", "TRIMESTRE","HORA","MINUTOS"]]

# ‚úÖ Guardar dimensiones en SQLite
engine = create_engine("sqlite:///mortality_dw.db")

df_codigos.to_sql("dim_causa", engine, if_exists="replace", index=False)
df_divipola.to_sql("dim_ubicacion", engine, if_exists="replace", index=False)
df_tiempo.to_sql("dim_tiempo", engine, if_exists="replace", index=False)

# 1. Crear mapeos para c√≥digos de 4 y 3 caracteres
map_cod4 = df_codigos.set_index("codigo")["descripcion"].to_dict()
map_cod3 = df_codigos.set_index("codigo_cie10_tres_caracteres")["descripcion"].to_dict()

# 2. Preparar columna de 3 caracteres en df_mortalidad
df_mortalidad["CODIGO_CIE10_3C"] = df_mortalidad["COD_MUERTE"].astype(str).str[:3]

# 3. Asignar descripci√≥n: primero con c√≥digo completo, luego con 3 caracteres si no existe
df_mortalidad["DESCRIPCION_CIE10"] = df_mortalidad["COD_MUERTE"].map(map_cod4)
df_mortalidad["DESCRIPCION_CIE10"] = df_mortalidad["DESCRIPCION_CIE10"].fillna(
    df_mortalidad["CODIGO_CIE10_3C"].map(map_cod3)
)

# 4. Leer la dimensi√≥n de ubicaci√≥n
dim_ubicacion = pd.read_sql("""
    SELECT COD_DANE, COD_DEPARTAMENTO, DEPARTAMENTO, MUNICIPIO, COD_MUNICIPIO
    FROM dim_ubicacion
""", engine)

# 5. Unir con df_mortalidad
df = df_mortalidad.merge(dim_ubicacion, on="COD_DANE", how="left")

# 6. Resolver columnas duplicadas si existen
df = df.rename(columns={
    "COD_DEPARTAMENTO_y": "COD_DEPARTAMENTO",
    "COD_MUNICIPIO_y": "COD_MUNICIPIO"
})
df = df.drop(columns=["COD_DEPARTAMENTO_x", "COD_MUNICIPIO_x"], errors='ignore')

# 7. Crear df_hechos incluyendo CODIGO_CIE10_3C
df_hechos = df[[
    "A√ëO", "MES", "HORA", "MINUTOS", "GRUPO_EDAD1", "SEXO",
    "COD_MUERTE", "CODIGO_CIE10_3C", "DESCRIPCION_CIE10",
    "COD_DANE", "COD_DEPARTAMENTO", "COD_MUNICIPIO"
]].copy()

# 8. Renombrar columnas finales
df_hechos.columns = [
    "A√ëO", "MES", "HORA", "MINUTOS", "EDAD", "SEXO",
    "CODIGO_CIE10", "CODIGO_CIE10_3C", "DESCRIPCION_CIE10",
    "COD_DANE", "COD_DEPARTAMENTO", "COD_MUNICIPIO"
]

# 9. Reorganizar columnas finales
df_hechos = df_hechos[[
    "A√ëO", "MES", "HORA", "MINUTOS", "EDAD", "SEXO",
    "CODIGO_CIE10", "CODIGO_CIE10_3C", "DESCRIPCION_CIE10",
    "COD_DANE", "COD_DEPARTAMENTO", "COD_MUNICIPIO"
]]

# ‚úÖ Guardar hechos
df_hechos.to_sql("hechos_mortalidad", engine, if_exists="replace", index=False)
print("‚úî Data Warehouse cargado correctamente en mortality_dw.db")

import sqlite3
conn = sqlite3.connect("mortality_dw.db")

tablas = conn.execute("SELECT name FROM sqlite_master WHERE type='table';").fetchall()
conn.close()

print("Tablas en la base de datos:", tablas)

# Reimportar librer√≠as
import sqlite3
import pandas as pd

# Conexi√≥n a la base de datos
conn = sqlite3.connect("mortality_dw.db")

# Consulta ajustada: total de muertes por departamento usando COD_DANE
query = """
SELECT
    du.DEPARTAMENTO,
    COUNT(hm.A√ëO) AS total_muertes
FROM hechos_mortalidad hm
JOIN dim_ubicacion du ON hm.cod_dane = du.COD_DANE
GROUP BY du.DEPARTAMENTO
ORDER BY total_muertes DESC
"""

# Ejecutar consulta
df_muertes_departamento = pd.read_sql_query(query, conn)
conn.close()

# Ver resultado
df_muertes_departamento

df_muertes_departamento["total_muertes"].sum()

#VALIDACIONES NA
#import sqlite3
# import pandas as pd

# # Conexi√≥n a la base de datos
# conn = sqlite3.connect("mortality_dw.db")

# # Consulta que extrae los registros con DEPARTAMENTO nulo
# query = """
# SELECT
#     hm.*,
#     du.DEPARTAMENTO
# FROM hechos_mortalidad hm
# LEFT JOIN dim_ubicacion du ON hm.cod_dane = du.COD_DANE
# WHERE du.DEPARTAMENTO IS NULL
# """

# # Ejecutar la consulta
# df_registros_sin_departamento = pd.read_sql_query(query, conn)
# conn.close()

# # Mostrar resultado
# df_registros_sin_departamento

#VALIDACIONES NA
# Reconectar
# conn = sqlite3.connect("mortality_dw.db")

# query = """
# SELECT DISTINCT hm.cod_dane
# FROM hechos_mortalidad hm
# LEFT JOIN dim_ubicacion du ON hm.cod_dane = du.COD_DANE
# WHERE du.COD_DANE IS NULL
# """

# df_codigos_faltantes = pd.read_sql_query(query, conn)
# conn.close()

# # Mostrar resultado
#df_codigos_faltantes

import sqlite3
import pandas as pd
import plotly.express as px
import json
import unicodedata

# üîß Funci√≥n para limpiar nombres
def quitar_tildes(texto):
    if not isinstance(texto, str):
        return texto
    texto = unicodedata.normalize('NFKD', texto).encode('ascii', errors='ignore').decode('utf-8')
    return texto.replace(".", "").replace(",", "").upper().strip()

# 1Ô∏è‚É£ Conexi√≥n y carga de datos desde SQLite
conn = sqlite3.connect("mortality_dw.db")
query = """
SELECT
    du.DEPARTAMENTO,
    COUNT(hm.A√ëO) AS total_muertes
FROM hechos_mortalidad hm
JOIN dim_ubicacion du ON hm.cod_dane = du.COD_DANE
GROUP BY du.DEPARTAMENTO
"""
df_mapa = pd.read_sql_query(query, conn)
conn.close()

# 2Ô∏è‚É£ Limpieza de nombres del DataFrame
df_mapa.rename(columns={"DEPARTAMENTO": "departamento"}, inplace=True)
df_mapa["departamento"] = df_mapa["departamento"].apply(quitar_tildes)

# 3Ô∏è‚É£ Reemplazos para empatar con el GeoJSON
reemplazos = {
    'SAN ANDRES': 'ARCHIPIELAGO DE SAN ANDRES PROVIDENCIA Y SANTA CATALINA',
    'BOGOTA DC': 'SANTAFE DE BOGOTA DC'  # ‚Üê CORRECTO seg√∫n el GeoJSON
}
df_mapa["departamento"] = df_mapa["departamento"].replace(reemplazos)

# 4Ô∏è‚É£ Cargar GeoJSON local
with open('/content/colombia.geo.json', 'r', encoding='utf-8') as f:
    geojson_colombia = json.load(f)

# 5Ô∏è‚É£ Crear campo limpio en el GeoJSON
for feature in geojson_colombia["features"]:
    nombre = feature["properties"].get("NOMBRE_DPT") or feature["properties"].get("DPTO_CNMBR")
    feature["properties"]["DPTO_CNMBR_CLEAN"] = quitar_tildes(nombre)

# 6Ô∏è‚É£ Validar coincidencias
geo_departamentos = set(f["properties"]["DPTO_CNMBR_CLEAN"] for f in geojson_colombia["features"])
no_match = df_mapa[~df_mapa["departamento"].isin(geo_departamentos)]

if not no_match.empty:
    print("‚ùó Departamentos sin coincidencia en el GeoJSON:")
    print(no_match[["departamento", "total_muertes"]])
else:
    print("‚úÖ Todos los departamentos coinciden correctamente con el GeoJSON.")

# 7Ô∏è‚É£ Crear mapa coropl√©tico
fig = px.choropleth(
    df_mapa,
    geojson=geojson_colombia,
    locations="departamento",
    color="total_muertes",
    featureidkey="properties.DPTO_CNMBR_CLEAN",
    color_continuous_scale="YlOrRd",
    range_color=(0, 40000),
    title="üó∫Ô∏è Distribuci√≥n de muertes por departamento en Colombia",
    custom_data=["departamento", "total_muertes"]
)

# Personalizar el tooltip (hover)
fig.update_traces(
    hovertemplate="<b>%{customdata[0]}</b><br>Muertes: %{customdata[1]:,}<extra></extra>"
)

# 8Ô∏è‚É£ Configurar vista del mapa
fig.update_geos(
    visible=True,
    projection_type="mercator",
    center={"lat": 4.5709, "lon": -74.2973},
    lataxis_range=[-5, 15],
    lonaxis_range=[-85, -65]
)

fig.update_layout(
    margin={"r": 0, "t": 40, "l": 0, "b": 0},
    height=600,
    coloraxis_colorbar=dict(
        title="Muertes",
        tickformat=",",  # ‚Üê esto quita la notaci√≥n 'k' y muestra n√∫meros con comas (ej. 40,000)
    )
)

# 9Ô∏è‚É£ Mostrar figura
fig.show()